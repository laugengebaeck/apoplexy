\subsection{Grundlegender Aufbau und Konzept der App}
Um die vom EMG-Sensor gelieferten Daten zu verarbeiten und dem Benutzer bzw. Patienten anschaulich darzustellen, erschien es sinnvoll, eine App für Mobilgeräte zu programmieren. Hierbei entschied ich mich, das weitverbreitete Betriebssystem Android zu verwenden und die App zu diesem (ab Android 6.0) kompatibel zu machen. Diese App sollte folgende grundlegende Funktionen enthalten:
\begin{itemize}
	\item \textbf{Durchführung von Bewegungsübungen:} Es sollten einfache Bewegungsübungen möglich sein, bei denen sowohl der aktuelle Messwert als auch die Messwerte im zeitlichen Verlauf angezeigt werden sollten. Dabei sollte auch ein Vergleich mit früheren Übungen möglich sein.
	\item \textbf{Ein durch Bewegungsübungen steuerbares Minispiel:} Die App sollte ein durch den Benutzer mithilfe von Bewegungen steuerbares Minispiel enthalten. dieses sollte möglichst einfach verständlich sein.
	\item \textbf{Ein verbindendes Gamification-System:} Sowohl bei normalen Übungen als auch beim Minispiel sollten Gamification-Elemente eingebracht werden. So sollte das Sammeln von Erfahrungspunkten (Experience Points, XP) möglich sein und es sollten für besondere Leistungen sogenannte Badges (Abzeichen) vergeben werden können. Dabei sollten die zu erbringenden Leistungen für die Badges in Form von Quests bzw. Aufgaben vorher für den Benutzer sichtbar sein.
	\item \textbf{Erinnerungen an die Übungen:} Die App sollte den Benutzer zu von ihm festgelegten Zeiten durch z.B. eine Benachrichtigung an die Durchführung seiner Übungen erinnern.
\end{itemize}
Ausgehend davon bot sich eine Gliederung in insgesamt vier für den Anwender sichtbare und miteinander verknüpfte Bildschirmseiten (bei Android Activities\cite{Src:AndroidKuenneth} genannt) an. Dies sind:
\begin{itemize}
	\item Eine \textbf{Startseite}, die die bisher erreichten Gamification-Erfolge zusammenfasst und kurze Informationstexte sowie Verknüpfungen zu den Übungsmöglichkeiten anbietet. Damit soll der Einstieg möglichst einfach gestaltet werden. Um die einzelnen Bereiche klar voneinander zu unterscheiden, kommt hier das einer Karteikarte ähnelnde Oberflächenelement \texttt{CardView} zum Einsatz.
	\item Eine \textbf{Übungsseite}, auf der man Übungen durchführen kann. Dabei zeigt ein tachoähnliches Oberflächenelement den aktuell festgestellten Messwert an, während mithilfe eines Diagramms die Messwerte während der gesamten Übung dargestellt werden. Diese Übung kann durch den Benutzer beliebig gestartet und beendet werden, während diese Seite auch eine Funktion zur Ansicht der aktuell verfügbaren Quests bereitstellt.
	\item Eine Seite für das \textbf{Minispiel}. Da dieses in einem späteren Abschnitt noch genauer beschrieben wird, soll hier nicht darauf eingegangen werden.
	\item Eine \textbf{Einstellungsseite}. Hier können Einstellungen getroffen werden, die für die restlichen Teile der App von Bedeutung sind. So kann man hier den eigenen Namen einstellen, die Gamification-Datenbank importieren und exportieren und die Übungserinnerungen konfigurieren. Für solche Seiten stellt das Android-SDK die Klasse \texttt{PreferenceFragment}\cite{Src:AndroidKuenneth} bereit.
\end{itemize}
Die einzelnen Funktionen sollen im folgenden näher erläutert werden. Screenshots der jeweiligen Activities befinden sich im Anhang.
\newpage
\subsection{Kommunikation mit dem Mikrocontroller}
Wie bereits erläutert, sendet der Mikrocontroller die Messdaten über eine Bluetooth-Verbindung. Um nun mit  diesem kommunizieren zu können, muss die Android-App eine solche Verbindung implementieren. Glücklicherweise enthält das Android-SDK (Software Development Kit) bereits eine Softwarebibliothek, die genau dies vereinfacht.\cite{Src:AndroidBT} \\ \\
Um eine Verbindung herzustellen, müssen zunächst einige Schritte durchlaufen werden, die nur in den Activities durchgeführt werden können. In dieser App benötigen zwei Activities Bluetooth-Zugriff: die Übungsseite und die Minispiel-Seite. Beide müssen unabhängig voneinander den Code zum Auffinden des zu verbindenden Bluetooth-Geräts implementieren. Dabei müssen beispielsweise die nötigen Berechtigungen überprüft, der Bluetooth-Adapter eingeschaltet und, sofern noch nicht geschehen, das Bluetooth-Gerät gekoppelt werden.\cite{Src:AndroidBT} \\ \\
Ist dies geschehen, kann mit dem Einlesen der per Bluetooth eintreffenden Werte begonnen werden. Diese Funktionalität ist in der App in der Klasse \texttt{BluetoothNoService} gekapselt. Um kurzzeitige Schwankungen der Messwerte auszugleichen, bietet es sich an, diese in einer \textit{Queue} zwischenzulagern. Eine Queue oder Warteschlange ist eine in der Informatik häufig eingesetzte Datenstruktur, die nach dem First In - First Out - Prinzip (FIFO) arbeitet, d.h. das Objekt, welches als erstes der Warteschlange hinzugefügt wurde, verlässt sie auch als erstes wieder. Für diesen Zweck eignet sie sich sehr gut, da im Laufe der Zeit immer wieder neue Messwerte hinzukommen, während ältere entfernt werden müssen. Damit keine zu alten Werte verwendet werden, ist es sinnvoll, die Länge der Queue auf 10 Werte zu beschränken. \\ \\
Zum Hinzufügen der Werte ist es sinnvoll, einen Thread zu implementieren, d.h. eine Funktion, die parallel zum übrigen Programm abläuft. Dieser Thread kann der Queue dann beständig neue Werte hinzufügen, sobald diese eintreffen. \\ \\
Um nun zu jedem Zeitpunkt einen Durchschnittswert aus der Queue berechnen zu können, bietet sich der Median der Werte an. Da die Werte jedoch als Spannung abgelegt sind und der EMG-Sensor Werte zwischen $U_{min} = 1.5 V$ und $U_{max} = 3.3 V$ ausgibt, ist es sinnvoll, dem Nutzer die Werte in Prozent des Maximalwertes zu präsentieren. Ein solcher Wert lässt sich mit folgender Gleichung berechnen (wobei $x$ der Median der Messwerte ist):
\begin{equation*}
p = 100 * \frac{x - U_{min}}{U_{max} - U_{min}}
\end{equation*}
Dieser Wert kann nun an die Benutzeroberfläche zur weiteren Darstellung übergeben werden.
\subsection{Konzept und programmiertechnische Umsetzung des Minispiels}
Das Minispiel soll es erlauben, ein virtuelles Flugzeug über eine Gebirgslandschaft mit Bergen unterschiedlicher Höhe zu steuern. Dabei bestimmt die gemessene Muskelaktivität die Höhe des Flugzeugs. Je höher die Aktivität, desto höher fliegt das Flugzeug. Das Ziel ist es dabei, das Flugzeug möglichst lange fliegen zu lassen, ohne gegen einen Berg zu stoßen. Dieses Spielprinzip ähnelt teilweise dem erfolgreichen Smartphone-Spiel \glqq Flappy Bird\grqq . Es wäre wünschenswert, wenn es gelänge, an den Erfolg des genannten Spielprinzips anzuknüpfen. \\ \\
Zur Umsetzung des Minispiels wurde die Möglichkeit des Android-SDKs genutzt, eigene Oberflächenelemente (sogenannte \textit{Views}\cite{Src:CustomView}) zu erstellen. Eine solche View beinhaltet in diesem Fall das Spiel und übernimmt dessen Darstellung. Das Android-System fordert dabei, dass man bestimmte, für die eigene View spezifische Methoden überschreibt. Dies sind im einzelnen:
\begin{itemize}
	\item \texttt{onDraw()}: Hier wird der sichtbare Teil der View gezeichnet.\cite{Src:CustomView} Was gezeichnet wird, hängt von der boolesche Objektvariable \texttt{inGame} der View ab, welche den Spielzustand (innerhalb oder außerhalb des Spiels) speichert. Befindet man sich außerhalb des Spiels, wird ein Text angezeigt, der darauf hinweist, dass durch einen Klick das Spiel gestartet werden kann. Innerhalb des Spiels müssen mehr Elemente gezeichnet werden. Zunächst jedoch wird der aktuelle Messwert des \texttt{BluetoothNoService} übernommen. \\ \\
	Nun werden anhand dieses Messwerts die Koordinaten der oberen linken Ecke des Flugzeugs bestimmt. Damit kann festgestellt werden, ob das Flugzeug gegen den Berg direkt vor ihm gestoßen ist. In diesem Fall ist das Spiel verloren. Ein entsprechender Infotext wird angezeigt und das Spiel durch die \texttt{handleTap()}-Methode beendet. \\ \\
	Ansonsten können der blaue Hintergrund, die grünen Berge sowie das als Icon vorliegende Flugzeug gezeichnet werden.
	\item \texttt{onSizeChanged()} und \texttt{onMeasure()}: Diese Methoden werden aufgerufen, wenn das System beispielsweise bei einer Drehung des Bildschirms eine Größenänderung der View anfordert.\cite{Src:CustomView} Entsprechend wird dann eine neue Höhe und Breite festgelegt. Daraufhin können alle von diesen abhängigen Teile der View neu generiert werden. Hier sind dies der Hintergrund und die prozedural zufällig (bezüglich ihrer Höhe) generierten Berge.
	\item \texttt{onTouchEvent()}: Diese Methode verarbeitet Touch-Eingaben bzw. Klicks. \cite{Src:InteractiveView} Android bietet dazu eine sogenannten \texttt{GestureDetector} an, der einfache und komplizierte Gesten erkennen kann. In diesem Fall muss jedoch nur das Tippen auf den Bildschirm erkannt werden und entsprechend das Spiel gestartet oder gestoppt werden. Dies übernimmt die Methode \texttt{handleTap()}.
\end{itemize}
\texttt{handleTap()} führt nun einige Schritte aus, die für das Starten bzw. Stoppen des Spiels nötig sind. Die bereits erwähnte \texttt{inGame}-Variable wird nun negiert, so dass der Spielzustand wechselt. Befindet man sich danach innerhalb des Spiels, so müssen nur die Höhen der Berge neu generiert werden. Dazu benutzt man einen einfachen Zufallsgenerator. \\ \\
Befindet man sich jedoch anschließend außerhalb des Spiels, so sind mehr Schritte durchzuführen. Die Liste der Berge sowie die Liste der Bluetooth-Messwerte müssen zurückgesetzt werden. Davor jedoch sollten entsprechende Gamification-Bewertungsfunktionen aufgerufen werden, die feststellen, wie viele XP beziehungsweise welche Badges der Nutzer für diese Leistung erhält. Die dazu nötigen Funktionen werden im nächsten Abschnitt genauer beschrieben. Nach den jeweiligen Änderungen wird die View natürlich neu gezeichnet. \\ \\
Das Android-Grafik-Framework unterscheidet beim Zeichnen im Übrigen dazwischen, was gezeichnet wird (bestimmt von der Klasse \texttt{Canvas}) und wie es gezeichnet wird (geregelt durch die Klasse \texttt{Paint}).\cite{Src:CustomView} Ein solches \texttt{Paint}-Objekt bestimmt dabei unter anderem Farbe, Stil und Schrift, die auf ein Objekt angewendet werden. Durch diese Teilung ist es möglich, \texttt{Paint}-Objekte schon vor der Benutzung zu erstellen und anschließend wiederzuverwenden. Da Views oft neu gezeichnet werden, kann dadurch die Performance verbessert und die Benutzeroberfläche flüssiger werden.\cite{Src:CustomView} \\ \\
Das fertige Spiel lässt sich nun folgendermaßen steuern: Zu Beginn erscheint der Text \glqq Um das Spiel zu beginnen, berühre den Bildschirm.\grqq Tippt man auf diesen erscheint die Oberfläche des Spiels. Das Flugzeug kann auf dieser nun ausschließlich durch Muskelaktivität und nicht durch Touch-Gesten oder ähnliches gesteuert werden. Stößt man nun gegen einen Berg oder tippt man erneut auf den Bildschirm, wird das Spiel beendet, wobei im ersteren Fall ein zusätzlicher Hinweis (\glqq Du bist gegen einen Berg gestoßen. Du verlierst!\grqq) erscheint. Anschließend wird die für das Spiel zu vergebende XP-Punktzahl berechnet und angezeigt sowie auf eventuell abgeschlossene Quests überprüft.
% ggf. Koordinatenberechnung genauer beschreiben

\subsection{Umsetzung der Gamification in der App}
% TODO Sqlite + Tabellenstruktur beschreiben (Bestandteile Quest/Badge)
% TODO XP-Verteilungs-Funktionen (Kriterien?)
% TODO Badge-Completition-Funktion (Popup) + Anzeige available bzw. completed Badges
% TODO Vergleich mit Gamification-Theorie -> erfüllt?
\subsection{Funktionsweise des Benachrichtigungssystems}
Das Benachrichtigungssystem besteht aus einer Reihe von Funktionen, die vorrangig durch die Einstellungsseite gesteuert werden. Die erste dieser Funktionen erledigt eine seit Android 8 für das Senden von Benachrichtigungen nötige Maßnahme, indem sie einen Benachrichtigungskanal einrichtet. Mithilfe dessen ist es dem Benutzer möglich, die Benachrichtigungen über die Systemeinstellungen zu unterdrücken.\cite{Src:AndroidNotify} Das Erstellen des Kanals erfolgt bei jedem Aufruf der Startseite, aber nach dem ersten Mal bleibt dies wirkungslos, sodass nur genau ein Kanal erstellt wird. \\ \\
Eine weitere Funktion ist für das Setzen einer Erinnerung zuständig. Sie liest aus den Einstellungen (sogenannte \texttt{SharedPreferences}) aus, ob und wann erinnert werden soll. Nachdem alle bisherigen Erinnerungen gelöscht wurden, kann eine neue gesetzt werden. Dazu verwendet die App den System-Service \texttt{AlarmManager}\cite{Src:NotifyDroid}. Sobald die gewünschte Zeit erreicht wurde, ruft dieser einen \texttt{BroadcastReceiver} auf. Solche \texttt{BroadcastReceiver} sind ein fester Bestandteil des Android-SDK und können auf vielfältige Meldungen durch das Android-System reagieren.\cite{Src:AndroidKuenneth} In diesem Fall wird hier eine Methode zum Senden der Benachrichtigung aufgerufen. \\ \\
Wird eine solche Benachrichtigung gesendet, ist sie systemweit für den Nutzer sichtbar und erinnert ihn daran, seine Übungen durchzuführen. Bei Klick auf die Benachrichtigung öffnet sich die Startseite der App. \\ \\
Schließlich lassen sich, wie bereits erwähnt, sämtliche im \texttt{AlarmManager} gespeicherten Erinnerungen auch wieder löschen, wovon entsprechend der Einstellungen Gebrauch gemacht wird.\footnote[3]{Die Implementierung des Benachrichtigungssystems basiert teilweise auf einer in  \cite{Src:NotifyDroid} vorgestellten Lösung.}