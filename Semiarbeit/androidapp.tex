\subsection{Grundlegender Aufbau und Konzept der App}
Um die vom EMG-Sensor gelieferten Daten zu verarbeiten und dem Benutzer bzw. Patienten anschaulich darzustellen, erschien es sinnvoll, eine App für Mobilgeräte zu programmieren. Hierbei entschied ich mich, das weitverbreitete Betriebssystem Android zu verwenden und die App zu diesem (ab Android 6.0) kompatibel zu machen, wobei zur Umsetzung die Programmiersprache Kotlin\cite{Src:Kotlin} verwendet wurde. Diese App sollte folgende grundlegende Funktionen enthalten:
\begin{itemize}
	\item \textbf{Durchführung von Bewegungsübungen:} Es sollten einfache Bewegungsübungen möglich sein, bei denen sowohl der aktuelle Messwert als auch die Messwerte im zeitlichen Verlauf angezeigt werden sollten. Dabei sollte auch ein Vergleich mit früheren Übungen möglich sein.
	\item \textbf{Ein durch Bewegungsübungen steuerbares Minispiel:} Die App sollte ein durch den Benutzer mithilfe von Bewegungen steuerbares Minispiel enthalten. dieses sollte möglichst einfach verständlich sein.
	\item \textbf{Ein verbindendes Gamification-System:} Sowohl bei normalen Übungen als auch beim Minispiel sollten Gamification-Elemente eingebracht werden. So sollte das Sammeln von Erfahrungspunkten (Experience Points, XP) möglich sein und es sollten für besondere Leistungen sogenannte Badges (Abzeichen) vergeben werden können. Dabei sollten die zu erbringenden Leistungen für die Badges in Form von Quests bzw. Aufgaben vorher für den Benutzer sichtbar sein.
	\item \textbf{Erinnerungen an die Übungen:} Die App sollte den Benutzer zu von ihm festgelegten Zeiten durch z.B. eine Benachrichtigung an die Durchführung seiner Übungen erinnern.
\end{itemize}
Ausgehend davon bot sich eine Gliederung in insgesamt vier für den Anwender sichtbare und miteinander verknüpfte Bildschirmseiten (bei Android Activities\cite{Src:AndroidKuenneth} genannt) an. Dies sind:
\begin{itemize}
	\item Eine \textbf{Startseite}, die die bisher erreichten Gamification-Erfolge zusammenfasst und kurze Informationstexte sowie Verknüpfungen zu den Übungsmöglichkeiten anbietet. Damit soll der Einstieg möglichst einfach gestaltet werden. Um die einzelnen Bereiche klar voneinander zu unterscheiden, kommt hier das einer Karteikarte ähnelnde Oberflächenelement \texttt{CardView} zum Einsatz.
	\item Eine \textbf{Übungsseite}, auf der man Übungen durchführen kann. Dabei zeigt ein tachoähnliches Oberflächenelement den aktuell festgestellten Messwert an, während mithilfe eines Diagramms die Messwerte während der gesamten Übung dargestellt werden. Diese Übung kann durch den Benutzer beliebig gestartet und beendet werden, während diese Seite auch eine Funktion zur Ansicht der aktuell verfügbaren Quests bereitstellt.
	\item Eine Seite für das \textbf{Minispiel}. Da dieses in einem späteren Abschnitt noch genauer beschrieben wird, soll hier nicht darauf eingegangen werden.
	\item Eine \textbf{Einstellungsseite}. Hier können Einstellungen getroffen werden, die für die restlichen Teile der App von Bedeutung sind. So kann man hier den eigenen Namen einstellen, die Gamification-Datenbank importieren und exportieren und die Übungserinnerungen konfigurieren. Für solche Seiten stellt das Android-SDK die Klasse \texttt{PreferenceFragment}\cite{Src:AndroidKuenneth} bereit.
\end{itemize}
Activities werden von Android intern auf dem sogenannten \textit{Back Stack} verwaltet, der basierend auf den abstrakten Datentyp Stack ein Zurückkehren zur vorherigen Activity erlaubt. Allgemein ist beim Arbeiten mit Activities das Lebenszyklus-Modell zu beachten, das beschreibt, auf welche Weise Activities gestartet, pausiert und gestoppt werden können.\cite{Src:AndroidKuenneth} Die einzelnen Bestandteile der App sollen im folgenden näher erläutert werden. Screenshots der jeweiligen Activities befinden sich im Anhang.
\newpage
\subsection{Kommunikation mit dem Mikrocontroller}
Wie bereits erläutert, sendet der Mikrocontroller die Messdaten über eine Bluetooth-Verbindung. Um nun mit  diesem kommunizieren zu können, muss die Android-App eine solche Verbindung implementieren. Glücklicherweise enthält das Android-SDK (Software Development Kit) bereits eine Softwarebibliothek, die genau dies vereinfacht.\cite{Src:AndroidBT} \cite{Src:AndroidKuenneth} \\ \\
Um eine Verbindung herzustellen, müssen zunächst einige Schritte durchlaufen werden, die nur in den Activities durchgeführt werden können. In dieser App benötigen zwei Activities Bluetooth-Zugriff: die Übungsseite und die Minispiel-Seite. Beide müssen unabhängig voneinander den Code zum Auffinden des zu verbindenden Bluetooth-Geräts implementieren. Dabei müssen beispielsweise die nötigen Berechtigungen überprüft, der Bluetooth-Adapter eingeschaltet und, sofern noch nicht geschehen, das Bluetooth-Gerät gekoppelt werden.\cite{Src:AndroidBT} \cite{Src:AndroidKuenneth} \\ \\
Ist dies geschehen, kann mit dem Einlesen der per Bluetooth über das Protokoll RFCOMM (Radio Frequency Communication)\cite{Src:AndroidKuenneth} eintreffenden Werte begonnen werden. Diese Funktionalität ist in der App in der Klasse \texttt{BluetoothNoService} gekapselt. Um kurzzeitige Schwankungen der Messwerte auszugleichen, bietet es sich an, diese in einer \textit{Queue} zwischenzulagern. Eine Queue oder Warteschlange ist eine in der Informatik häufig eingesetzte Datenstruktur, die nach dem First In - First Out - Prinzip (FIFO) arbeitet, d.h. das Objekt, welches als erstes der Warteschlange hinzugefügt wurde, verlässt sie auch als erstes wieder. Für diesen Zweck eignet sie sich sehr gut, da im Laufe der Zeit immer wieder neue Messwerte hinzukommen, während ältere entfernt werden müssen. Damit keine zu alten Werte verwendet werden, ist es sinnvoll, die Länge der Queue auf 10 Werte zu beschränken. \\ \\
Zum Hinzufügen der Werte ist es sinnvoll, einen Thread zu implementieren, d.h. eine Funktion, die parallel zum übrigen Programm abläuft. Dieser Thread kann der Queue dann beständig neue Werte hinzufügen, sobald diese eintreffen. \\ \\
Um nun zu jedem Zeitpunkt einen Durchschnittswert aus der Queue berechnen zu können, bietet sich der Median der Werte an. Da die Werte jedoch als Spannung abgelegt sind und der EMG-Sensor Werte zwischen $U_{min} = 1.5 V$ und $U_{max} = 3.3 V$ ausgibt, ist es sinnvoll, dem Nutzer die Werte in Prozent des Maximalwertes zu präsentieren. Ein solcher Wert lässt sich mit folgender Gleichung berechnen (wobei $x$ der Median der Messwerte ist):
\begin{equation*}
p = 100 * \frac{x - U_{min}}{U_{max} - U_{min}}
\end{equation*}
Dieser Wert kann nun an die Benutzeroberfläche zur weiteren Darstellung übergeben werden.
\subsection{Konzept und programmiertechnische Umsetzung des Minispiels}
Das Minispiel soll es erlauben, ein virtuelles Flugzeug über eine Gebirgslandschaft mit Bergen unterschiedlicher Höhe zu steuern. Dabei bestimmt die gemessene Muskelaktivität die Höhe des Flugzeugs. Je höher die Aktivität, desto höher fliegt das Flugzeug. Das Ziel ist es dabei, das Flugzeug möglichst lange fliegen zu lassen, ohne gegen einen Berg zu stoßen. Dieses Spielprinzip ähnelt teilweise dem erfolgreichen Smartphone-Spiel \glqq Flappy Bird\grqq . Es wäre wünschenswert, wenn es gelänge, an den Erfolg des genannten Spielprinzips anzuknüpfen. \\ \\
Zur Umsetzung des Minispiels wurde die Möglichkeit des Android-SDKs genutzt, eigene Oberflächenelemente (sogenannte \textit{Views}\cite{Src:CustomView}) zu erstellen. Eine solche View beinhaltet in diesem Fall das Spiel und übernimmt dessen Darstellung. Das Android-System fordert dabei, dass man bestimmte, für die eigene View spezifische Methoden überschreibt. Dies sind im einzelnen:
\begin{itemize}
	\item \texttt{onDraw()}: Hier wird der sichtbare Teil der View gezeichnet.\cite{Src:CustomView} \cite{Src:AndroidKuenneth} Was gezeichnet wird, hängt von der boolesche Objektvariable \texttt{inGame} der View ab, welche den Spielzustand (innerhalb oder außerhalb des Spiels) speichert. Befindet man sich außerhalb des Spiels, wird ein Text angezeigt, der darauf hinweist, dass durch einen Klick das Spiel gestartet werden kann. Innerhalb des Spiels müssen mehr Elemente gezeichnet werden. Zunächst jedoch wird der aktuelle Messwert des \texttt{BluetoothNoService} übernommen. \\ \\
	Nun werden anhand dieses Messwerts die Koordinaten der oberen linken Ecke des Flugzeugs bestimmt. Damit kann festgestellt werden, ob das Flugzeug gegen den Berg direkt vor ihm gestoßen ist. In diesem Fall ist das Spiel verloren. Ein entsprechender Infotext wird angezeigt und das Spiel durch die \texttt{handleTap()}-Methode beendet. \\ \\
	Ansonsten können der blaue Hintergrund, die grünen Berge sowie das als Icon vorliegende Flugzeug gezeichnet werden.
	\item \texttt{onSizeChanged()} und \texttt{onMeasure()}: Diese Methoden werden aufgerufen, wenn das System beispielsweise bei einer Drehung des Bildschirms eine Größenänderung der View anfordert.\cite{Src:CustomView} Entsprechend wird dann eine neue Höhe und Breite festgelegt. Daraufhin können alle von diesen abhängigen Teile der View neu generiert werden. Hier sind dies der Hintergrund und die prozedural zufällig (bezüglich ihrer Höhe) generierten Berge.
	\item \texttt{onTouchEvent()}: Diese Methode verarbeitet Touch-Eingaben bzw. Klicks. \cite{Src:InteractiveView} Android bietet dazu eine sogenannten \texttt{GestureDetector} an, der einfache und komplizierte Gesten erkennen kann. In diesem Fall muss jedoch nur das Tippen auf den Bildschirm erkannt werden und entsprechend das Spiel gestartet oder gestoppt werden. Dies übernimmt die Methode \texttt{handleTap()}.
\end{itemize}
\texttt{handleTap()} führt nun einige Schritte aus, die für das Starten bzw. Stoppen des Spiels nötig sind. Die bereits erwähnte \texttt{inGame}-Variable wird nun negiert, so dass der Spielzustand wechselt. Befindet man sich danach innerhalb des Spiels, so müssen nur die Höhen der Berge neu generiert werden. Dazu benutzt man einen einfachen Zufallsgenerator. \\ \\
Befindet man sich jedoch anschließend außerhalb des Spiels, so sind mehr Schritte durchzuführen. Die Liste der Berge sowie die Liste der Bluetooth-Messwerte müssen zurückgesetzt werden. Davor jedoch sollten entsprechende Gamification-Bewertungsfunktionen aufgerufen werden, die feststellen, wie viele XP beziehungsweise welche Badges der Nutzer für diese Leistung erhält. Die dazu nötigen Funktionen werden im nächsten Abschnitt genauer beschrieben. Nach den jeweiligen Änderungen wird die View natürlich neu gezeichnet. \\ \\
Das Android-Grafik-Framework unterscheidet beim Zeichnen im Übrigen dazwischen, was gezeichnet wird (bestimmt von der Klasse \texttt{Canvas}) und wie es gezeichnet wird (geregelt durch die Klasse \texttt{Paint}).\cite{Src:CustomView} Ein solches \texttt{Paint}-Objekt bestimmt dabei unter anderem Farbe, Stil und Schrift, die auf ein Objekt angewendet werden. Durch diese Teilung ist es möglich, \texttt{Paint}-Objekte schon vor der Benutzung zu erstellen und anschließend wiederzuverwenden. Da Views oft neu gezeichnet werden, kann dadurch die Performance verbessert und die Benutzeroberfläche flüssiger werden.\cite{Src:CustomView} \\ \\
Das fertige Spiel lässt sich nun folgendermaßen steuern: Zu Beginn erscheint der Text \glqq Um das Spiel zu beginnen, berühre den Bildschirm.\grqq Tippt man auf diesen erscheint die Oberfläche des Spiels. Das Flugzeug kann auf dieser nun ausschließlich durch Muskelaktivität und nicht durch Touch-Gesten oder ähnliches gesteuert werden. Stößt man nun gegen einen Berg oder tippt man erneut auf den Bildschirm, wird das Spiel beendet, wobei im ersteren Fall ein zusätzlicher Hinweis (\glqq Du bist gegen einen Berg gestoßen. Du verlierst!\grqq) erscheint. Anschließend wird die für das Spiel zu vergebende XP-Punktzahl berechnet und angezeigt sowie auf eventuell abgeschlossene Quests überprüft.
\subsection{Umsetzung der Gamification in der App}
Im Bereich der Gamification entschied ich mich, ein (Erfahrungs-)Punktesystem und Quests bzw. Badges einzuführen. Für jede durchgeführte Übung bzw. für jedes Spielen des Minispiels werden dabei abhängig von den aufgenommenen Messwerten Punkte verteilt. Dabei gelten für die Verteilung folgende Kriterien:
\begin{itemize}
	\item Bei einer \textbf{Übung} wird eine Liste $L$ der prozentualen Messwerte erstellt. Aus dieser kann dann die Punktzahl $P$ berechnet werden:
	\begin{align*}
	P = \frac{min(L) + avg(L) + max(L)}{3}
	\end{align*}
	Dabei berechnet $min(L)$ den Minimalwert der Liste, $avg(L)$ den Durchschnittswert der Liste und $max(L)$ den Maximalwert der Liste.
	\item Beim \textbf{Minispiel} gelten die Regeln für eine Übung grundsätzlich weiter. Jedoch werden als Bonus zusätzlich $2 \cdot d$ XP vergeben, wobei $d$ die Anzahl der aufgenommenen Messwerte bis zum Absturz des Flugzeugs darstellt.
\end{itemize}
Natürlich wird der Nutzer auch jeweils über die vergebene Punktzahl mithilfe einer im unteren Bildschirmteil eingeblendeten \texttt{Toast}-Benachrichtigung informiert. \\ \\
Bei den bereits erwähnten Quests entschied ich mich, verschiedene Kriterien bzw. Anforderungen für die Fertigstellung der Quest vorauszusetzen. Um diese bei den einzelnen Quests flexibel regulieren zu können, erschien es sinnvoll, solche Daten in einer lokalen Datenbank zu speichern, auf welche die App dann zugreifen kann. Android bietet dafür die sehr kompakte Datenbankbibliothek \textit{SQLite} an, welche ein relationales Datenbanksystem implementiert und über die standardisierte Datenbanksprache \textit{SQL} angesprochen werden kann.\cite{Src:AndroidKuenneth} Besonders wichtig ist hierbei, dass keine Server-Software benötigt wird, sondern die Datenbank einfach in einer einzelnen Textdatei gespeichert werden kann, was im Kontext einer Android-App vieles vereinfacht.\cite{Src:AndroidKuenneth} \\ \\
Die Datenbanktabelle besteht nun aus den folgenden Spalten, welche eine einzelne Quest kennzeichnen:
 \begin{longtabu} to \linewidth {|l|l|X|}
	\hline
	\textbf{Spaltenname} & \textbf{Spaltentyp} & \textbf{Beschreibung} \\[0.3em] \hline \endhead
	\texttt{\_id} & \texttt{INT} & Die eindeutige Identifikationsnummer der Quest, über die sie aufgerufen und verändert werden kann. \\[0.5em] \hline	
	\texttt{title} & \texttt{VARCHAR(50)} & Der Titel der Quest. Dieser kann bis zu 50 Zeichen lang sein \\[0.5em] \hline
	\texttt{description} & \texttt{VARCHAR(150)} & Eine Beschreibung der Quest, die bis zu 150 Zeichen lang sein kann. Sie sollte möglichst die in den restlichen Spalten definierten Ziele zum Erfüllen der Quest zusammenfassen.  \\[0.5em] \hline
	\texttt{icon} & \texttt{INT} & Ein Zahl zwischen 1 und 5, die für die Anzeige der Quest eines von 5 vordefinierten Symbolen auswählt. \\[0.5em] \hline
	\texttt{requiredXP} & \texttt{INT} & Gibt den XP-Stand an, der zur Anzeige der Quest nötig ist. \\[0.5em] \hline
	\texttt{finishedXP} & \texttt{INT} & Gibt den XP-Stand an, der zum Beenden der Quest notwendig ist. \\[0.5em] \hline
	\texttt{earnedXP} & \texttt{INT} & Gibt die Anzahl an XP an, die der Nutzer für die Beendigung der Quest erhält. \\[0.5em] \hline
	\texttt{overPercentage} & \texttt{INT} & Gibt einen Messwert an, über dem man für eine bestimmte Zeit sein muss, um die Quest zu beenden. \\[0.5em] \hline
	\texttt{timeOverPercentage} & \texttt{INT} & Gibt die Zeitspanne an, während der man über dem genannten Messwert sein muss. \\[0.5em] \hline
	\texttt{minimumPercentage} & \texttt{INT} & Gibt eine Prozentzahl bzw. einen Messwert an, die mindestens einmal während einer Übung erreicht werden muss, um die Quest zu beenden. \\[0.5em] \hline
	\texttt{isCompleted} & \texttt{BOOL} & Gibt an, ob die Quest bereits beendet und damit in ein Badge umgewandelt wurde. \\[0.5em] \hline
\end{longtabu}
In allen INT-Spalten außer \texttt{\_id} und \texttt{icon} kann auch eine $0$ stehen. Dies bedeutet dann, dass die entsprechende Anforderung bei dieser Quest nicht benötigt wird. \\ \\
Nun ist es relativ einfach, die Quests und Badges in der App anzuwenden. Nach jeder Übung und jedem Spiel kann nun anhand der in der Tabelle festgelegten Kriterien überprüft werden, ob eine der Quests beendet wurde. Dazu müssen drei Bedingungen erfüllt sein: die \texttt{minimumPercentage}-Bedingung (der Wert wurde mindestens einmal erreicht), die \texttt{overPercentage}-Bedingung (der Wert wurde für die angegebene Zeitspanne überschritten) und ein entsprechender XP-Stand. \\ \\
Ist dies der Fall, kann die Quest durch eine Datenbankabfrage auf \glqq erledigt\grqq ~gesetzt werden. Die durch die Quest verdienten XP-Punkte können dem Nutzer nun gutgeschrieben werden. Gleichzeitig wird mithilfe eines \texttt{DialogFragment}s dem Benutzer ein Dialog angezeigt, der ihn über die abgeschlossenen Quests und die dafür erhaltenen Erfahrungspunkte informiert. \\ \\
Natürlich ist es dem Nutzer auch möglich, sich die erhaltenen Badges bzw. die zur Verfügung stehenden Quests anzuzeigen. Im ersteren Fall wird diese Funktion durch einen Button auf der Startseite aufgerufen, im letzteren Fall durch einen Button auf der Übungsseite. In beiden Fällen wird ein \texttt{Dialog} mit einer \texttt{ListView} angezeigt, die Elemente auflisten kann. Hier sind dies die Quests bzw. Badges, welche über einen \texttt{CursorAdapter} einfach aus der Datenbank abgerufen werden können. \\ \\
In Hinsicht auf die Umsetzung der Gamification ist jedoch auch zu betrachten, inwieweit die App der Gamification-Theorie folgt, um daraus möglicherweise Rückschlüsse auf die Wirksamkeit zu ziehen. Bezüglich der Spielertypen ist die App beispielsweise eher für Forscher und Erfolgstypen ausgelegt, da sich die Gamification-Elemente aktuell darauf fokussieren, den Nutzer Erfolge erreichen zu lassen. Gesellige und Killer dagegen haben wenig Möglichkeiten, mit anderen zu interagieren und mit ihnen in Wettbewerb zu treten, da eine Mehrspielerfunktion fehlt, welche den zeitlichen Rahmen der Arbeit gesprengt hätte. Die Einbindung einer solchen Funktion wäre jedoch eine Erweiterungsmöglichkeit. \\ \\
Jedoch ist die für Gamification wichtige Handlungstransparenz gegeben, da der Nutzer sich seinen XP-Stand und die verfügbaren Quests einfach ansehen kann. Neue Herausforderungen sind trotzdem nur begrenzt gegeben, da das Hinzufügen von Quests in der aktuellen Version noch schwierig ist. Dies ließe sich durch eine Updatefunktion über das Internet beheben. Das Minispiel ist weder zu einfach noch zu schwer, da es sich am bekannten Prinzip des Spiels \textit{Flappy Bird} orientiert. Das ermöglicht es dem Nutzer, in einen Flow zu kommen. \\ \\
Auch das Prinzip der operanten Konditionierung wurde umgesetzt, denn die Vergabe von Erfahrungspunkten und Badges erfolgt abhängig von den Messwerten immer unterschiedlich. Die Belohnung in einem variablen Intervall ist dabei jedoch nicht möglich, da die Vergabe nur jeweils nach einer Übung oder einem Spiel erfolgen kann. \\ \\
Im Bereich der spieltypischen Mechanismen wurden einige umgesetzt. So enthält die App, wie bereits beschrieben, ein Erfahrungspunkte-System. Ein Highscore jedoch ist aufgrund der fehlenden Mehrspieler-Möglichkeiten nicht vorhanden. Hingegen ist ein System aus Quests und Badges vorhanden, die so verknüpft sind, dass aus einer abgeschlossenen Quest ein Badge erzeugt wird. Damit existiert ein sichtbarer Status, der der App ein Ziel und eine Struktur gibt und den Fortschritt des Nutzers symbolisiert. Ein sinnvolles Ziel bzw. Epic Meaning ist hier in jedem Fall vorhanden, denn der Benutzer möchte seine Armlähmung bekämpfen.
\subsection{Funktionsweise des Benachrichtigungssystems}
Das Benachrichtigungssystem besteht aus einer Reihe von Funktionen, die vorrangig durch die Einstellungsseite gesteuert werden. Die erste dieser Funktionen erledigt eine seit Android 8 für das Senden von Benachrichtigungen nötige Maßnahme, indem sie einen Benachrichtigungskanal einrichtet. Mithilfe dessen ist es dem Benutzer möglich, die Benachrichtigungen über die Systemeinstellungen zu unterdrücken.\cite{Src:AndroidNotify} Das Erstellen des Kanals erfolgt bei jedem Aufruf der Startseite, aber nach dem ersten Mal bleibt dies wirkungslos, sodass nur genau ein Kanal erstellt wird. \\ \\
Eine weitere Funktion ist für das Setzen einer Erinnerung zuständig. Sie liest aus den Einstellungen (sogenannte \texttt{SharedPreferences}) aus, ob und wann erinnert werden soll. Nachdem alle bisherigen Erinnerungen gelöscht wurden, kann eine neue gesetzt werden. Dazu verwendet die App den System-Service \texttt{AlarmManager}\cite{Src:NotifyDroid}. Sobald die gewünschte Zeit erreicht wurde, ruft dieser einen \texttt{BroadcastReceiver} auf. Solche \texttt{BroadcastReceiver} sind ein fester Bestandteil des Android-SDK und können auf vielfältige Meldungen durch das Android-System, welche auf Systemereignisse hinweisen, reagieren.\cite{Src:AndroidKuenneth} In diesem Fall wird hier eine Methode zum Senden der Benachrichtigung aufgerufen. \\ \\
Wird eine solche Benachrichtigung gesendet, ist sie systemweit für den Nutzer sichtbar und erinnert ihn daran, seine Übungen durchzuführen. Bei Klick auf die Benachrichtigung öffnet sich die Startseite der App. \\ \\
Schließlich lassen sich, wie bereits erwähnt, sämtliche im \texttt{AlarmManager} gespeicherten Erinnerungen auch wieder löschen, wovon entsprechend der Einstellungen Gebrauch gemacht wird.\footnote[3]{Die Implementierung des Benachrichtigungssystems basiert teilweise auf einer in  \cite{Src:NotifyDroid} vorgestellten Lösung.}